\chapter{Conclusion}

FastClick and \Ac{vpp} are both fast software routers which vectorize
packets during processing and are close to each other performance
wise. MoonRoute on the other hand has a significant performance
advantage over both of them, being 20-30\% faster at routing.

While the performance of \Ac{vpp} v18.10 starts dropping at around 20
\Ac{fib} entries, \Ac{vpp} v16.09 can hold it's highest performance
with up to 200 \Ac{ip4} \Ac{fib} entries. 

Reaching the maximum number of entries \Ac{vpp}'s throughput nearly
halves with \Ac{vpp} v18.10 only supporting up to around 255,000
\Ac{ip4} \Ac{fib} entries. For this number of router table entries it
is remarkably slower than FastClick with $2^{20}$ entries, even though
it is slightly faster with little table entries.

The best advantage of \Ac{vpp} over it's competitors is it's feature
richness. It's during runtime configurable packet processing graph
offers for example different tunneling protocols. Settings allow to
move the main thread to a dedicated CPU core which in turn allows live
inserts of 255k routing table entries with a throughput impact of less
than a percent.

Although \Ac{vpp} performs badly with very big routing tables, it's
modularity in combination with the rich options to connect it to
virtual machines, containers or local high performance applications,
make it a well choice for building virtual networks for highly
virtualized environments or implementation of \Ac{vnf}.

Next research steps could include more specific benchmarks regarding
behavior on receiving control packets or \Ac{ip6} specific protocol
specific benchmarking methodology like RFC 5180 \cite{rfc5180}.
Furthermore the performance change over different \Ac{vpp} versions
can be analyzed closer by testing a version between 16.09 and 18.10
and the latest v19.01 which was just released during the creation of
this paper. Especially the code changes leading to the performance
differences are of interest and how for example FastClick achieves it
high performance with many routes.

% TODO: this has to sound better

% more next steps: 
% - code based comparison of lookup table: v16.09, v18.10, fastclick
% - more latency research. model/plain why latency
%   per load graph looks like it does (read the relevant code)
% - try to elaborate a better upper bound throughput model as in: 
%   "Performance Exploration of Software-based Packet Processing Systems"
% 	- test with different cpu's